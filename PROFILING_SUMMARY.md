# Rust vs C++/Cython dense_sandwich: Profiling Summary

## Quick Reference

**Date**: January 12, 2026  
**Branch**: rust-migration  
**Test System**: Apple M1 (ARM64), Python 3.12

### Bottom Line

**C++/Cython is 6.8√ó faster on average**, ranging from 1.9√ó (small matrices) to 10.8√ó (large matrices).

**Root cause**: C++/Cython uses Apple Accelerate BLAS (~80-100 GFLOP/s), while Rust uses manual SIMD (~9 GFLOP/s).

## Key Files

| File | Purpose |
|---|---|
| [RUST_CPP_COMPARISON.md](RUST_CPP_COMPARISON.md) | Detailed analysis with recommendations |
| [comparison_results.txt](comparison_results.txt) | Raw benchmark output |
| [compare_rust_cpp_sandwich.py](compare_rust_cpp_sandwich.py) | Profiling script |
| [rust_cpp_comparison.png](rust_cpp_comparison.png) | 4-panel visualization |
| [rust_cpp_summary.png](rust_cpp_summary.png) | Summary statistics plot |

## Performance at a Glance

### Average Performance
- **Rust**: 6.79 GFLOP/s (6.8% hardware utilization)
- **C++/Cython**: 46.18 GFLOP/s (46.2% hardware utilization)
- **Gap**: 6.80√ó

### Worst Case (1M √ó 50 matrix)
- **Rust**: 273.7 ms (9.13 GFLOP/s)
- **C++/Cython**: 25.4 ms (98.36 GFLOP/s)
- **Gap**: 10.77√ó

### Memory Layout Penalty (100k √ó 50)
- **Rust**: 2.16√ó slower with C-contiguous arrays
- **C++/Cython**: 1.12√ó slower with C-contiguous arrays

## Implementation Comparison

| Feature | Rust | C++/Cython |
|---|:---:|:---:|
| **BLAS Integration** | ‚ùå No | ‚úÖ Yes (Accelerate) |
| **Cache Blocking** | Fixed (512) | Adaptive |
| **Tuning Parameters** | 0 | 3 (thresh1d, kratio, innerblock) |
| **Memory Layout Handling** | Poor (2.16√ó penalty) | Good (1.12√ó penalty) |
| **Algorithm Selection** | Single | Adaptive |

## Recommendations

### üî¥ Priority 1: Add BLAS Integration to Rust

Use `accelerate-src` on macOS or `openblas-src` cross-platform:

```toml
[dependencies]
accelerate-src = "0.3"  # macOS
# or
openblas-src = { version = "0.10", features = ["static"] }  # Cross-platform
cblas-sys = "0.1"
```

**Expected impact**: 5-8√ó speedup (from 9 ‚Üí 50-80 GFLOP/s)

### üü° Priority 2: Fix Cache Blocking

Make K_BLOCK adaptive based on matrix size and L2 cache size.

**Expected impact**: 1.5-2√ó additional speedup

### üü° Priority 3: Improve Memory Layout Handling

Add C-contiguous optimized path to eliminate 2.16√ó penalty.

**Expected impact**: 2√ó speedup for C-order arrays

### Total Potential Improvement

With all optimizations: **10-15√ó speedup** (from 7 ‚Üí 70-100 GFLOP/s)

## Testing Methodology

### How to Run the Comparison

```bash
cd /Users/marc/repos/tabmat
pixi run -e py312 postinstall  # Build both implementations
pixi run -e py312 python compare_rust_cpp_sandwich.py
pixi run -e docs python visualize_comparison.py  # Generate plots
```

### What It Tests

- 6 matrix sizes: 10k√ó10, 10k√ó50, 100k√ó10, 100k√ó50, 1M√ó10, 1M√ó50
- 2 memory layouts: Fortran (column-major), C (row-major)
- 20 warm iterations per test
- Fixed seed (42) for reproducibility

### Metrics Collected

- Execution time (mean, median, min, max, std)
- GFLOP/s (mean and peak)
- Memory layout impact
- cProfile function-level breakdown

## Visualizations

### rust_cpp_comparison.png (4 panels)
1. **Throughput**: GFLOP/s bar chart with hardware peak line
2. **Timing**: Log-scale plot with speedup annotations
3. **Speedup**: Gap by matrix size (shows trend)
4. **Memory Layout**: Fortran vs C-order sensitivity

### rust_cpp_summary.png
- Avg GFLOP/s comparison
- Hardware utilization %
- Avg speedup
- Memory penalty

## Next Steps

1. **Decision Point**: Enhance Rust or keep C++/Cython?
   - **Option A**: 2-month project to achieve parity
   - **Option B**: Keep C++ for dense, use Rust for sparse

2. **If enhancing Rust**:
   - Week 1-2: BLAS integration
   - Week 3: Adaptive cache blocking
   - Week 4: Memory layout fixes
   - Week 5-6: Testing & benchmarking
   - Week 7: Production deployment

3. **Success Criteria**:
   - Rust ‚â• 80% of C++ performance (‚â•36 GFLOP/s avg)
   - Memory penalty ‚â§ 1.3√ó for C-order
   - Pass all existing tests
   - No regression in sparse operations

---

**Generated by**: compare_rust_cpp_sandwich.py and visualize_comparison.py  
**See also**: [RUST_CPP_COMPARISON.md](RUST_CPP_COMPARISON.md) for detailed analysis
